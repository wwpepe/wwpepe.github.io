/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HugoHighlight
});
module.exports = __toCommonJS(main_exports);
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");
var import_obsidian = require("obsidian");

// lib/parser.ts
var HugoHighlightParser = class {
  constructor(line) {
    this.lines = /* @__PURE__ */ new Set();
    var _a;
    if (!/{.*}/.test(line)) {
      return;
    }
    let match = line.match(/hl_lines="?(\d+)"?\s*/i);
    if (match) {
      this.addLine(Number.parseInt(match[1]));
      return;
    }
    match = line.match(/hl_lines=\[(.*)\]\s*/i);
    if (!match) {
      return;
    }
    const lineEntries = match[1].split(",").map((s) => s.trim());
    for (const entry of lineEntries) {
      const isRange = entry.includes("-");
      const quotedMatch = entry.match(/^"(.+)"$/);
      if (isRange) {
        if (quotedMatch) {
          const [start, end] = quotedMatch[1].split("-").map((n) => Number.parseInt(n));
          if (start < end) {
            this.addRange(start, end);
          }
        }
      } else {
        const unquoted = (_a = quotedMatch == null ? void 0 : quotedMatch.at(1)) != null ? _a : entry;
        const num = Number.parseInt(unquoted);
        if (!Number.isNaN(num)) {
          this.addLine(num);
        }
      }
    }
  }
  addLine(line) {
    this.lines.add(line);
  }
  addRange(start, end) {
    if (start > end) {
      [start, end] = [end, start];
    }
    for (let line = start; line <= end; line++) {
      this.lines.add(line);
    }
  }
  removeRange(start, end) {
    if (start > end) {
      [start, end] = [end, start];
    }
    for (let line = start; line <= end; line++) {
      this.lines.delete(line);
    }
  }
  containsLine(line) {
    return this.lines.has(line);
  }
  /**
   * Format `lines` into Hugo's `hl_lines` attribute format,
   * Converting consecutive lines into ranges
   */
  formatAttr() {
    let out = "hl_lines=[";
    if (this.lines.size > 0) {
      const lines = [...this.lines];
      lines.sort((a, b) => a - b);
      for (let i = 0; i < lines.length; i++) {
        const rangeStart = lines[i];
        let rangeEnd = rangeStart;
        while (lines[i] + 1 === lines[i + 1]) {
          rangeEnd = lines[i + 1];
          i++;
        }
        if (rangeStart === rangeEnd) {
          out += `"${rangeStart}",`;
        } else {
          out += `"${rangeStart}-${rangeEnd}",`;
        }
      }
      out = out.slice(0, -1);
    }
    out += "]";
    return out;
  }
};
function updateHighlightLine(newAttr, lineText) {
  if (/hl_lines=\[.*\]/i.test(lineText)) {
    return lineText.replace(/hl_lines=\[.*\]/i, newAttr);
  } else {
    const indexOfOpenBrace = lineText.indexOf("{");
    const indexOfCloseBrace = lineText.lastIndexOf("}");
    if (indexOfOpenBrace >= indexOfCloseBrace) {
      return lineText.trimEnd() + ` {${newAttr}}`;
    }
    const inside = lineText.slice(indexOfOpenBrace + 1, indexOfCloseBrace).trim();
    return lineText.slice(0, indexOfCloseBrace).trimEnd() + (inside.length === 0 ? newAttr : `,${newAttr}`) + lineText.slice(indexOfCloseBrace);
  }
}

// main.ts
var HugoHighlight = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.showHighlightMenu = (menu, editor, view) => {
      var _a;
      if (!view.file)
        return;
      const cache = this.app.metadataCache.getFileCache(view.file);
      const selections = editor.listSelections();
      const minLine = Math.min(...selections.map((sel) => Math.min(sel.anchor.line, sel.head.line)));
      const maxLine = Math.max(...selections.map((sel) => Math.max(sel.anchor.line, sel.head.line)));
      (_a = cache == null ? void 0 : cache.sections) == null ? void 0 : _a.forEach((section) => {
        const { end: codeblockEnd, start: codeblockStart } = section.position;
        if (section.type === "code" && minLine > codeblockStart.line && maxLine < codeblockEnd.line) {
          const lineText = editor.getLine(codeblockStart.line);
          const hlParser = new HugoHighlightParser(lineText);
          const updateCodeblockFence = () => {
            const newAttr = hlParser.formatAttr();
            const newLineText = updateHighlightLine(newAttr, lineText);
            editor.replaceRange(newLineText, { ch: 0, line: codeblockStart.line }, { ch: lineText.length, line: codeblockStart.line });
          };
          const allSelectedLinesAreHighlighted = selections.every((sel) => {
            let [start, end] = [sel.head.line - codeblockStart.line, sel.anchor.line - codeblockStart.line];
            if (start > end) {
              [start, end] = [end, start];
            }
            for (let line = start; line <= end; line++) {
              if (!hlParser.containsLine(line)) {
                return false;
              }
            }
            return true;
          });
          if (allSelectedLinesAreHighlighted) {
            menu.addItem((item) => {
              item.setTitle("Unhighlight selected lines").setIcon("eraser").onClick(() => {
                for (const sel of selections) {
                  hlParser.removeRange(sel.head.line - codeblockStart.line, sel.anchor.line - codeblockStart.line);
                }
                updateCodeblockFence();
              });
            });
          } else {
            menu.addItem((item) => {
              item.setTitle("Highlight selected lines").setIcon("highlighter").onClick(() => {
                for (const sel of selections) {
                  hlParser.addRange(sel.head.line - codeblockStart.line, sel.anchor.line - codeblockStart.line);
                }
                updateCodeblockFence();
              });
            });
          }
        }
      });
    };
  }
  async onload() {
    this.registerEditorExtension(import_view.ViewPlugin.fromClass(HighlightViewPlugin, { decorations: (plugin) => plugin.decorations }));
    this.registerEvent(
      this.app.workspace.on("editor-menu", this.showHighlightMenu)
    );
  }
};
var HighlightViewPlugin = class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (update.viewportChanged || update.docChanged) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    const decorations = [];
    let beginLineNumber = 0;
    let hlParser = null;
    for (const { from, to } of view.visibleRanges) {
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to,
        enter(node) {
          if (node.type.name.includes("HyperMD-codeblock-begin")) {
            const line = view.state.doc.lineAt(node.from);
            beginLineNumber = line.number;
            const lineText = view.state.sliceDoc(line.from, line.to);
            hlParser = new HugoHighlightParser(lineText);
          }
          if (node.type.name.includes("HyperMD-codeblock-bg")) {
            const line = view.state.doc.lineAt(node.from);
            const lineNumber = line.number - beginLineNumber;
            if (hlParser !== null && hlParser.containsLine(lineNumber)) {
              decorations.push(import_view.Decoration.line({ class: "hugo-line-highlight" }).range(node.from));
            }
          }
        }
      });
    }
    return import_state.RangeSet.of(decorations, true);
  }
};
